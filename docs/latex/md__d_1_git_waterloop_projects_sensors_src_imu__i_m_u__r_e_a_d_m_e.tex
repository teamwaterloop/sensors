This controls all the \hyperlink{class_i_m_u}{I\+MU} sensors on the pod. Each sensor contains three types of sub sensors. These sub sensors are {\ttfamily Gyro\+Scope}, {\ttfamily Accelerometer} and {\ttfamily Magnetometer}. The data gathered from each sensor is in J\+S\+ON format.

Example J\+S\+ON data returned\+:


\begin{DoxyCode}
\textcolor{comment}{// This contains data from Gyroscope}
\{\textcolor{stringliteral}{"time"}:1009,\textcolor{stringliteral}{"sensor"}:\textcolor{stringliteral}{"gyro"},\textcolor{stringliteral}{"data"}:[-1.54875,12.19750,11.36625]\}

\textcolor{comment}{// This contains data from only Accelerometer}
\{\textcolor{stringliteral}{"time"}:1009,\textcolor{stringliteral}{"sensor"}:\textcolor{stringliteral}{"accelerometer"},\textcolor{stringliteral}{"data"}:[-0.02300,-0.02300,-0.02300]\}

\textcolor{comment}{// This contains data from only Magnetometer}
\{\textcolor{stringliteral}{"time"}:1009,\textcolor{stringliteral}{"sensor"}: \textcolor{stringliteral}{"magnetometer"}, \textcolor{stringliteral}{"data"}:[0.41986,0.41986,0.41986]\}
\end{DoxyCode}


More about data recieved is mentioned later on.

\subsection*{How to Use}

This set of sensors are controlled by {\ttfamily \hyperlink{class_i_m_u_pool}{I\+M\+U\+Pool}} class. An Object must be created of this class to gather data from all the sensor. To create an object, you have to pass in a parameter to specify how many imu sensors are on the pod


\begin{DoxyCode}
\hyperlink{class_i_m_u_pool}{IMUPool} imus(2);            \textcolor{comment}{// create 2 imu sensors}
\end{DoxyCode}


Before recording any sensor values, we have to check if all the imu sensors are working. To do this, call {\ttfamily sensors\+Working} method and it will return true to signal the working of all the sensors and false even if one sensor is not working


\begin{DoxyCode}
\textcolor{keywordflow}{if} (imus.sensorsWorking())\{\}    \textcolor{comment}{// success}
\textcolor{keywordflow}{else}\{\}                          \textcolor{comment}{// failure}
\end{DoxyCode}


\subsubsection*{Overview of functions to gather data}

Each component of \hyperlink{class_i_m_u}{I\+MU} sensor returns x, y and z values. Since the data is formatted in J\+S\+ON format, the data received by any function call includes x, y and z for that particular sensor. J\+S\+ON format also includes a time in milliseconds. This time is the time elapsed since the Arduino has started working.

Data in J\+S\+ON format cannot be received as a string but rather you can print it directly to the Serial. To do this you can make a call {\ttfamily serial\+Print}.


\begin{DoxyCode}
imus.serialPrint(0, GYRO);        \textcolor{comment}{// data for Gyroscope from sensor 0}
imus.serialPrint(1, ACCEL);    \textcolor{comment}{// data for Accelerometer from sensor 1}
imus.serialPrint(1, MAG);         \textcolor{comment}{// data for Magnetometer from sensor 1}
\end{DoxyCode}


If for some reason read fails for any component of any sensor, the output for that component will be {\ttfamily -\/99999.\+00000} for x, y and z axis. Since the value of any sensor component will never be {\ttfamily -\/99999.\+00000}, we can detect failure and take actions accordingly.


\begin{DoxyCode}
\textcolor{comment}{// In this data, Gyroscope read failed}
\{\textcolor{stringliteral}{"time"}:1039,\textcolor{stringliteral}{"sensor"}:\textcolor{stringliteral}{"gyroscope"}:[-99999.00000,-99999.00000,-99999.00000]\}
\end{DoxyCode}


Now that above functions return values for Serial communications, we may need values in float format so that our pod can utilize them. In order to do that, there are following functions\+:


\begin{DoxyCode}
imus.getX(0, GYRO);                 \textcolor{comment}{// x data for Gyroscope and from sensor 0}
imus.getY(1, ACCEL);                \textcolor{comment}{// y data for Accelerometer and from sensor 1}
imus.getZ(1, MAG);                  \textcolor{comment}{// z data for Magnetometer and from sensor 1}
\end{DoxyCode}


To get the number of sensors in the subsystem, call the method {\ttfamily get\+Total}.


\begin{DoxyCode}
\{C++\}
imus.getTotal();                    // will return 2 based on our declaration of the object above
\end{DoxyCode}


\subsection*{Documentation of \hyperlink{class_i_m_u}{I\+MU} class used by \hyperlink{class_i_m_u_pool}{I\+M\+U\+Pool} class}

{\ttfamily \hyperlink{class_i_m_u}{I\+MU}} class is used by \hyperlink{class_i_m_u_pool}{I\+M\+U\+Pool} to make everything work. A client can choose to use {\ttfamily \hyperlink{class_i_m_u}{I\+MU}} class if he/she wishes to do so. Keep in mind this class only supports one \hyperlink{class_i_m_u}{I\+MU} sensor and does not return data in J\+S\+ON format. But, this class can be modified to change the functionality of each components for \hyperlink{class_i_m_u}{I\+MU} sensor. These changes will also show up on {\ttfamily \hyperlink{class_i_m_u_pool}{I\+M\+U\+Pool}}.

Create an object of this class.


\begin{DoxyCode}
\hyperlink{class_i_m_u}{IMU} sensor;
\end{DoxyCode}


If you are not satisfied by how {\ttfamily Gyroscope} or {\ttfamily Accelerometer} or {\ttfamily Magnetometer} component works and outputs data, you can change the settings of each component using {\ttfamily setup} methods. These methods have default values so you do not have to specify every parameter.


\begin{DoxyCode}
\{C++\}
// setupGyro() specifies the settings for the gyroscope.
// * scale sets the full-scale range of the gyroscope. scale can be set to either 245, 500, or 2000
// * sampleRatesets the output data rate (ODR) of the gyro
//   sampleRate can be set between 1-6
//   1 = 14.9    4 = 238
//   2 = 59.5    5 = 476
//   3 = 119     6 = 952
// * flipX, flipY, and flipZ are booleans that can automatically switch the positive/negative
//   orientation of the three gyro axes.
void setupGyro(int scale=245, int sampleRate=3, bool flipX=false, bool flipY=false, bool flipZ=false);

// setupAccel() specifies the settings for the accelerometer.
// * scale sets the full-scale range of accelerometer. The scale can be 2, 4, 8 or 16
// * sampleRate sets the output data rate of the accelerometer. If Gyroscope is running,
//   the sample rate is same as gyroscope. Same rate can be be 1-6:
//   1 = 10 Hz    4 = 238 Hz
//   2 = 50 Hz    5 = 476 Hz
//   3 = 119 Hz   6 = 952 Hz
void setupAccel(int scale=8, int sampleRate=1);

// setupMag() specifies the settings for the magnetometer.
// * scale sets the full-scale range of the magnetometer. Mag scale can be 4, 8, 12, or 16
// * sampleRate sets the output data rate (ODR) of the magnetometer.
//   mag data rate can be 0-7:
//   0 = 0.625 Hz  4 = 10 Hz
//   1 = 1.25 Hz   5 = 20 Hz
//   2 = 2.5 Hz    6 = 40 Hz
//   3 = 5 Hz      7 = 80 Hz
// * tempComp enables or disables temperature compensation of the magnetometer.
// * operatingMode sets the operating mode of the magnetometer. operatingMode can be 0-2:
//   0 = continuous conversion
//   1 = single-conversion
//   2 = power down
void setupMag(int scale=12, int sampleRate=5, bool tempComp=false, int operatingMode=0);
\end{DoxyCode}


You can get data from each data component of the sensor by using {\ttfamily get} methods. Before getting these x, y and z values, you have to read the sensor. To read the sensor, use the {\ttfamily read} method. This method returns true if the read was successful and false if it was unsuccessful.


\begin{DoxyCode}
\{C++\}
read(GYRO);       // read GYRO
read(ACCEL);      // reada ACCEL
read(MAG);        // read MAG
\end{DoxyCode}


After the read is successful, you can go ahead and get data from that component. Data acquired from each component is of type {\ttfamily float} and it is precise to {\ttfamily 5 decimal points}.


\begin{DoxyCode}
\{C++\}
// X values
getX(GYRO);       // GYRO X Value
getX(ACCEL);      // ACCEL X Value
getX(MAG);        // MAG X Value

// Y values
getY(GYRO);       // GYRO Y Value
getY(ACCEL);      // ACCEL Y Value
getY(MAG);        // MAG Y Value

// Z values
getZ(GYRO);       // GYRO Z Value
getZ(ACCEL);      // ACCEL Z Value
getZ(MAG);        // MAG Z Value
\end{DoxyCode}
 